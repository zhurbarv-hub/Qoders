# Исправление ошибки HTTP 422 при обновлении токена бота

## Описание проблемы

**Симптомы:**
- Web API недоступен по адресу `http://localhost:8000`
- Ошибка в системе уведомлений: `HTTP 422: {"detail":[{"type":"string_too_short","loc":["body","password"],"msg":"String should have at l...`
- Бот работает в режиме Fallback (прямой доступ к БД)

**Причина:**
Telegram бот пытается обновить JWT токен для доступа к Web API, используя учётные данные из переменных окружения:
- `BOT_API_USERNAME=admin`
- `BOT_API_PASSWORD=admin`

Однако Web API требует минимальную длину пароля **6 символов** (согласно схеме `LoginRequest` в `web/app/models/schemas.py`), а текущий пароль `"admin"` содержит только **5 символов**.

**Расположение проблемы:**
1. **Файл конфигурации:** `.env` (строки 83-84)
2. **Валидация пароля:** `web/app/models/schemas.py` (строка 12)
3. **Использование учётных данных:** `bot/services/token_manager.py` (строка 112-126)

---

## Стратегия решения

### Вариант 1: Изменить пароль бота в базе данных (рекомендуется)

**Обоснование:**
- Соответствует требованиям безопасности (пароль минимум 6 символов)
- Не требует изменения кода валидации
- Минимальные риски для существующих пользователей

**Шаги:**
1. Обновить пароль для пользователя `admin` в базе данных (установить пароль длиной ≥6 символов, например `admin123`)
2. Обновить переменную окружения `BOT_API_PASSWORD` в файле `.env`
3. Перезапустить бот для применения новых учётных данных

### Вариант 2: Ослабить требования валидации (не рекомендуется)

**Обоснование:**
- Снижает уровень безопасности
- Может потребовать изменения в нескольких местах
- Не соответствует best practices

**Шаги:**
1. Изменить `min_length` в схеме `LoginRequest` с 6 на 4
2. Обновить соответствующие схемы в других модулях
3. Перезапустить Web API

---

## Детальное решение (Вариант 1)

### Шаг 1: Идентификация пользователя бота

**Цель:** Найти запись пользователя с username='admin' в таблице `users`

**SQL запрос:**
```
SELECT id, username, role, is_active FROM users WHERE username = 'admin'
```

**Ожидаемый результат:** ID пользователя `admin`

---

### Шаг 2: Генерация нового хешированного пароля

**Требования к паролю:**
- Минимальная длина: 6 символов
- Рекомендуемый пароль: `admin123` (или более сложный для продакшена)

**Алгоритм хеширования:** bcrypt (используется в `web/app/services/auth_service.py`)

**Процесс генерации:**
1. Использовать функцию `get_password_hash()` из модуля аутентификации
2. Сгенерировать bcrypt-хеш для нового пароля
3. Получить строку хеша для записи в БД

---

### Шаг 3: Обновление пароля в базе данных

**Цель:** Записать новый хеш пароля в таблицу `users`

**SQL операция:**
```
UPDATE users 
SET password = '<bcrypt_hash>' 
WHERE username = 'admin'
```

**Критерии успеха:**
- Запрос обновил ровно 1 строку
- Значение поля `password` изменено на новый хеш

---

### Шаг 4: Обновление переменной окружения

**Файл:** `.env`

**Изменение:**
```
Было:
BOT_API_PASSWORD=admin

Стало:
BOT_API_PASSWORD=admin123
```

**Валидация:**
- Пароль должен совпадать с тем, что использовался при генерации хеша
- Длина ≥ 6 символов

---

### Шаг 5: Перезапуск сервисов

**Порядок перезапуска:**
1. Перезапустить Web API (для применения изменений БД)
2. Перезапустить Telegram бота (для загрузки новых учётных данных)

**Проверка успешности:**
- Бот успешно получает JWT токен от Web API
- В логах бота появляется сообщение: `✅ Токен успешно обновлён`
- Режим работы: `API mode` (не Fallback)

---

### Шаг 6: Тестирование интеграции

**Сценарий тестирования:**
1. Проверить доступность Web API по адресу `http://localhost:8000`
2. Выполнить запрос логина от имени бота
3. Убедиться, что токен обновляется без ошибок 422
4. Проверить работу уведомлений через бота

**Критерии успешного теста:**
- HTTP статус 200 при логине
- Токен содержит корректные данные (username, role)
- Автообновление токена работает каждый час (согласно `BOT_TOKEN_REFRESH_INTERVAL`)

---

## Альтернативный подход: Создание отдельного пользователя для бота

**Обоснование:**
- Разделение прав доступа (принцип наименьших привилегий)
- Упрощение аудита действий бота
- Независимость от учётной записи admin

**Структура решения:**

### Создание пользователя бота

**Параметры:**
- Username: `telegram_bot`
- Password: `bot_secure_password_123` (минимум 6 символов)
- Role: `manager` (или создать отдельную роль `bot`)
- Email: `bot@system.local`
- is_active: `true`

**SQL команда для создания:**
```
INSERT INTO users (username, password, email, role, is_active, created_at)
VALUES ('telegram_bot', '<bcrypt_hash>', 'bot@system.local', 'manager', true, datetime('now'))
```

### Обновление конфигурации

**Изменения в `.env`:**
```
BOT_API_USERNAME=telegram_bot
BOT_API_PASSWORD=bot_secure_password_123
```

### Настройка прав доступа

**Необходимые права для бота:**
- Чтение списка клиентов (`GET /api/clients`)
- Чтение и создание дедлайнов (`GET/POST /api/deadlines`)
- Доступ к dashboard статистике (`GET /api/dashboard/stats`)
- Отправка уведомлений (внутренний API)

**Реализация:**
- Если используется role-based access control (RBAC), назначить соответствующие permissions
- Проверить доступ в `web/app/dependencies.py` (функции `get_current_user`, `require_role`)

---

## Диагностика и мониторинг

### Логирование процесса обновления токена

**Файл:** `bot/services/token_manager.py`

**Ключевые события для логирования:**
1. Попытка обновления токена (строка ~105)
2. Успешное получение токена (строка ~130)
3. Ошибки HTTP 422 (строка ~140-144)
4. Ошибки HTTP 401 (строка ~134-138)
5. Ошибки подключения (строка ~146-148)

**Формат сообщений:**
- Успех: `✅ Токен успешно обновлён. Истекает в {time}`
- Ошибка валидации: `HTTP 422: {error_detail}` (текущая ситуация)
- Ошибка аутентификации: `Неверные учётные данные бота: {error_text}`

### Мониторинг статуса бота

**Индикаторы проблем:**
- Режим работы: `Fallback (прямой доступ к БД)` вместо `API mode`
- Статус Web API: `Недоступен` вместо `Доступен`
- Ошибки в логах бота с кодом 422

**Инструменты проверки:**
1. Чтение последних записей из лог-файла бота
2. Проверка доступности endpoint `/api/auth/login` (должен возвращать 200 для корректных учётных данных)
3. Ручная проверка длины пароля в `.env`

---

## Рекомендации по безопасности

### Требования к паролю бота

**Минимальные требования (текущие):**
- Длина: ≥ 6 символов
- Алгоритм хеширования: bcrypt

**Рекомендуемые улучшения:**
- Длина: ≥ 12 символов
- Использование букв разного регистра, цифр и спецсимволов
- Регулярная ротация пароля (каждые 90 дней)

### Защита учётных данных

**Текущее состояние:**
- Учётные данные хранятся в `.env` файле
- `.env` должен быть в `.gitignore`

**Best practices:**
1. Никогда не коммитить `.env` файл в Git
2. Использовать `.env.example` как шаблон без реальных паролей
3. В продакшене использовать системы управления секретами (HashiCorp Vault, AWS Secrets Manager)
4. Ограничить права доступа к `.env` файлу на сервере (chmod 600)

### Аудит доступа

**Мониторинг действий бота:**
- Логирование всех API запросов от пользователя `telegram_bot`
- Отслеживание необычной активности (слишком частые запросы, попытки доступа к запрещённым ресурсам)
- Периодический анализ логов аутентификации

---

## Проверка результата

### Критерии успешного исправления

| Проверка | Текущее состояние | Ожидаемое состояние |
|----------|-------------------|---------------------|
| Web API статус | Недоступен | Доступен (HTTP 200) |
| Режим работы бота | Fallback (БД) | API mode |
| Ошибка обновления токена | HTTP 422 | Нет ошибок |
| Длина пароля в .env | 5 символов | ≥ 6 символов |
| Логи бота | Ошибка валидации | ✅ Токен обновлён |

### Команды для проверки

**1. Проверка доступности Web API:**
```
curl http://localhost:8000/api/health
```
Ожидаемый ответ: HTTP 200, JSON с информацией о статусе

**2. Тестовый логин с новым паролем:**
```
curl -X POST http://localhost:8000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "admin123"}'
```
Ожидаемый ответ: HTTP 200, JSON с `access_token`

**3. Проверка логов бота:**
Искать строки с текстом `"Токен успешно обновлён"` в последних записях лог-файла

**4. Проверка режима работы:**
Выполнить команду `/start` в боте и проверить сообщение о статусе системы

---

## Откат изменений (Rollback Plan)

### Если что-то пошло не так

**Шаг 1: Восстановить старый пароль**
```
UPDATE users 
SET password = '<old_bcrypt_hash>' 
WHERE username = 'admin'
```

**Шаг 2: Вернуть старое значение в .env**
```
BOT_API_PASSWORD=admin
```

**Шаг 3: Перезапустить сервисы**

**Шаг 4: Проверить работу в режиме Fallback**

### Сохранение резервной копии

**Перед началом изменений:**
1. Создать бэкап базы данных
2. Сохранить копию текущего `.env` файла
3. Записать текущий хеш пароля для возможности отката

---

## Временная шкала выполнения

| Этап | Описание | Расчётное время |
|------|----------|-----------------|
| 1 | Диагностика проблемы | 5 минут |
| 2 | Генерация нового пароля и хеша | 2 минуты |
| 3 | Обновление БД | 1 минута |
| 4 | Редактирование .env | 1 минута |
| 5 | Перезапуск сервисов | 3 минуты |
| 6 | Тестирование | 5 минут |
| **Итого** | | **~17 минут** |

---

## Связанные компоненты

### Зависимые модули

1. **bot/services/token_manager.py**
   - Отвечает за обновление JWT токенов
   - Использует учётные данные из конфигурации

2. **web/app/models/schemas.py**
   - Определяет схему валидации `LoginRequest`
   - Устанавливает минимальную длину пароля (6 символов)

3. **web/app/api/auth.py**
   - Обрабатывает запросы логина
   - Проверяет пароль через bcrypt

4. **backend/config.py** (или аналогичный файл настроек)
   - Загружает переменные окружения из `.env`
   - Предоставляет значения `BOT_API_USERNAME` и `BOT_API_PASSWORD`

### Файлы конфигурации

- `.env` - основной файл переменных окружения
- `.env.example` - шаблон для документации
- `database/kkt_services.db` - база данных SQLite (или PostgreSQL в продакшене)

---

## Предотвращение повторения проблемы

### Валидация конфигурации при запуске

**Реализовать проверку в `bot/main.py`:**

Добавить функцию валидации учётных данных при инициализации бота:
- Проверить, что `BOT_API_PASSWORD` соответствует требованиям (длина ≥ 6)
- Попытаться выполнить тестовый логин при старте бота
- Если логин не удался, вывести понятное сообщение об ошибке и остановить запуск

**Формат предупреждения:**
```
❌ ОШИБКА КОНФИГУРАЦИИ: Пароль BOT_API_PASSWORD должен содержать минимум 6 символов.
   Текущая длина: 5
   Отредактируйте файл .env и перезапустите бота.
```

### Документация требований

**Обновить `.env.example`:**

Добавить комментарий с требованиями к паролю:
```
# Учётные данные бота для аутентификации в Web API
# ВАЖНО: Пароль должен содержать минимум 6 символов
BOT_API_USERNAME=admin
BOT_API_PASSWORD=your_secure_password_here
```

### Автоматизированное тестирование

**Создать тест для проверки валидации:**
- Unit-тест для схемы `LoginRequest`
- Integration-тест для процесса логина бота
- CI/CD pipeline проверка конфигурации

---

## Заметки для разработчиков

### Почему требуется минимум 6 символов?

**Техническая причина:**
- Определено в Pydantic схеме `LoginRequest` через параметр `Field(..., min_length=6)`
- При получении запроса FastAPI автоматически валидирует входные данные
- Если валидация не проходит, возвращается HTTP 422 Unprocessable Entity

**Безопасность:**
- 6 символов - это минимальный базовый уровень безопасности
- Для продакшена рекомендуется увеличить до 8-12 символов
- Можно добавить требования сложности (буквы, цифры, спецсимволы)

### Как работает TokenManager?

**Жизненный цикл токена:**
1. При старте бота `TokenManager` инициализируется с учётными данными
2. Вызывается `refresh_token()` для получения первого токена
3. Токен сохраняется в `_current_token` и используется для всех API запросов
4. Каждый час (или по расписанию) токен автоматически обновляется
5. При ошибке обновления выполняется fallback на прямой доступ к БД

**Обработка ошибок:**
- HTTP 401: Неверные учётные данные
- HTTP 422: Ошибка валидации (текущая проблема)
- Connection Error: API недоступен
- Timeout: API не отвечает в течение `WEB_API_TIMEOUT` секунд
